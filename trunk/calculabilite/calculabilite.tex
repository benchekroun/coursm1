\documentclass{article}
\usepackage[utf8]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}


\title{Calculabilité et Complexité - Nicolas Ollinger}
\author{Alexandre Masson}
\date{15 Janvier 2013}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Fondements de l'informatique}le But du cours est de nous donner quelques éléments culturels pour comprendre comment certaines choses seront toujours valable dans 50 ans et pourquoi c'est de la science.\\\\Computability en Anglais , on s'intéresse à la propriété d’être calculable.\\\\Qu'est ce qui est calculable?\\\\ Complexité s’intéresse à la meilleur complexité que l'on peut obtenir avec un algorithme. Existe il des problèmes intrinsèquement plus complexes que d'autres (ex: tri , pas possible de faire mieux que O(nlog(n))).\\\\Il est possible ici de faire un parallèle entre Programmation et Algorithmique. Ces deux choses travaillent sur : comment trouver de programme (ou comment construire un programme qui résous un problème) et calculabilité et complexité détermine l'existence d'un programme pour résoudre un problème.\\\\thèse de Church-Turing(rien d'intuitif, quelque-soit le langage de prog, on ne pourra pas calculer plus de choses).\\\\Les programmes qui calculent des fonctions partielles , peuvent ne pas répondre à des problèmes.\\\\Un interprète, prend un programme et une donnée et renvoi le résultat du programme sur la donnée.Une fonction universelle existe dans tout modèle de calcul(Travaux de Alan Turing).\\\\Un programme qui affiche son propre code dans son exécution, existe dans tous les langages de programmation. Théorème de récurrence, pour toute fonction , il existe une fonction auto-référente( qui se prend elle même en paramètre) qui prend e code en paramètre et affiche son code. \\\\ il n'existe pas de programme qui prend un autre programme en paramètre et dit si celui-ci s’arrête  ou pas.\newpage
\section{Calculabilité}
\paragraph{Définition} Études des modèles de calcul et des propriétés qui sont indépendantes du modèle.\\\\On s'intéresse : 
\begin{itemize}
\item aux programmes vus à la fois comme : 
\begin{itemize}
\item chaîne de caractères (code source) : un mot sur un alphabet fini
\item un objet qui code une fonction (soit des chaînes -> les chaînes, soit des Entiers -> les Entiers).
\end{itemize}
\paragraph{Remarque}on confondra allègrement et sans scrupules les ensemble E*(ensemble de tous les mots d'un alphabet), N*(ensemble des couples d'entiers de taille*) , N ,... qui sont codables bijectivement et récursivement (codage et décodage calculables par un programme)  les uns en les autres.\\\\
\item problèmes de décision : problème auquel on répond par oui ou non, c'est un langage (donc un sous ensemble de E*).
\end{itemize}
\paragraph{Intuitivement}
Une fonction f est : E* -> E* partielle est calculable si il existe un programme tel que : $\forall$ x $\in$ $\sigma$ * .\\\\
Un problème de décision P $\subset$ $\sigma$ * est décidable si fp : x -> oui si p est x $\in$ P est calculable , non sinon.
\section{Motivation informelle(approche naïve)}Fixons un langage de programmation impératif IMP idéalisé. Code Source,entrée,sortie $\in$ UTF8*. Prenons eval(p,x) = y si les programme sur l'entrée x s'arrête en renvoyant y, $\perp$ sinon.\\\\$\phi$ p : $\sigma$ * -> $\sigma$ *\\$\phi$ (x) = eval(p,x).\\\\Question : Est ce que toute fonction est IMP-calculable? NON, il suffit de compter!\\\textbf{Prop : }Toutes les fonctions ne sont pas IMP-calculable.\\\textbf{Démonstration : }Comparons le nombre des fonctions et le nombre des programmes, $\sigma$ * est un ensemble infini dénombrable.\\$\sigma$ * -> $\sigma$ * n'est pas dénombrable.\\donc il existe des fonctions non IMP-calculable. $\sigma$ *  est dénombrable : il suffit d'énumérer par taille croissante et ordre lexicographique à taille fixée.\\\\$\sigma$ * -> $\sigma$ * n'est  \textsc{pas} dénombrable.\\\\Procédé de Cantor : \\\t par l'absurde , on suppose que $\sigma$ * -> $\sigma$ * est dénombrable : énumération($\phi$ i) tel que { $\phi$ i} = $\sigma$ * $\sigma$ * 
\paragraph{Remarque : }l'entrée est <p,x> codage dans la paire(p,x).
\paragraph{Proposition : }Il existe un programme universel U tel que $\forall$ p $\forall$ X U(<p,x>) = eval(p,x), il suffit de prendre pour U un interprète IMP codé en IMP.
\paragraph{Proposition  : }IMP-arrêt est IMP-indécidable.
\paragraph{Démonstration : }Par l'absurde. Supposons que IMP-arrêt soit IMP-décidable, idem qu'il existe un programme débug tel que $\phi$ debug (<p,x>) = {oui si $\phi$p(x) != $\perp$, NON sinon}.\\On construit un programme malicieux comme suit :  on lit X, on execute debug, si debug dis oui boucle infinie while 1 , sinon return , masi alors , $\phi$ malicieux(malicieux) répond oui si imp-arrêt dis non et non si imp arrête dis oui, donc ce programme ontredit IMP-arrêt CONTRADICTOIRE!!! donc IMP-arrêt n'est pas IMP-calculable.\\Comment utiliser ce résultats pour démontrer que d'autres problèmes sont indécidables
\paragraph{imp-arrêt}entrée : code source P.\\question : Est ce que $\phi$($\epsilon$) != $\perp$.\\\\On aimerais montrer que IMP-arrêt0 est lui aussi IMP-indécidable en montrant que IMP-arrêt est plus simple que IMP-arrêt0. On va construire un programme qui utilise IMP-arrêt0  pour résoudre imp-arrêt.\\\\

Est ce que $\phi$\_{p}(x) != $\perp$ \\\\On a montré que IMP-arrêt est indécidable on va dire que IMP-arrêt <=\_{imp} IMP-arrêt0.\\On va construire un programme qui utilise un programme qui résout IMP-arrêt0 pour résoudre IMP-arrêt. Dans IMP-arrêt, on a en entrée P et x, on doit manipuler P et x, pour contruire un programme P' qui va nourrir imp-arrêt0.\\\\Démonstration : Par l'absurde, on suppose qu'il existe un programme qui décide imp-arrêt0.\\\\On construit alors le programme suivant : \\\\Read Z;\\P:= $\pi$\_{1}(Z)\\X:= $\pi$\_{2}(Z)\\Q := le programme P où la première ligne [read Y] est remplacée par [read Y; Y := X];\\R := IMP-arrêt0(Q);\\write(R);\\\\Ce programme résout imp-arrêt, qui est imp-indécidable : CONTRADICTION. Donc IMP-arrêt0 est indécidable.\\\\Cette preuve utilise une technique d'évaluation partielle.\\\\\textbf{Proposition : } Il existe une fonction IMP-calculable s qui à <P,x> associe le code source d'un programme qui ignore son entrée et simule le programme P sur l'entrée x, c’est à dire : $\forall$ y, $\phi$s(<P,x>)(Y) = $\phi$p(x).\\\\\textbf{Proposition : } Il existe une fonction IMP-calculable s qui à <P,x> associe le code source d'un programme qui sur une entrée Y, simule le programme P sur l'entrée <X,Y>  : $\phi$s(<P,x>)(Y) = $\phi$p(<X,Y>). .\\\\\textbf{Démonstration : } Idem, mais remplacer [read Y] par [read Y, Y:= <X,Y>].\\\\Prop : il existe un programme IMP qui retourne son propre programme code source.\\\textbf{Démonstration : }\\Soit R le programme suivante : \\Read(Z);\\X:=$\pi$1(Z)\\Y := s'(<X,X>)\\write Y\\donc le programme s'(<R,R>) écrit son propre code source.\\\textbf{Bilan : }Ce qui précède ne dépend pas vraiment de IMP.\\Quelques principes sous-jacents :\begin{itemize}
\item dénombre de manière calculable les programmes;
\item possibilités d'enchainer, concaténer, composer des programmes.
\item existence d'un crochet <.,.> et de projection $\pi$1,$\pi$2 calculables.
\item existence d'un programme universel;
\item existence de fonctions d'évaluation partielle : s,s',...
\end{itemize}
La calculabilité s'intéresse aux propriétés des fonctions calculables qui sont indépendantes du modèles de calcul considéré
\section{Machines de Turing} Les MT sont le modèle de calcul de référence du cours. Il s'agit d'un modèle de machine mécanique abstrait.C'est le modèle de référence en complexité. A.M.Turing  : On computable numbers with an application to the Entscheidungproblem.1936
\subsection{Définitions} LE ruban est coupé en case, quantité finie d'information, on suppose qu'on a un alphabet fini qui nous permet d'écrire dans les cases du ruban, et le contenu d'un case c'est une lettre sur un alphabet fini.\\\\L’opérateur est une flèche qui pointe sur une case, il a le droit de mémoriser une quantité fini d'informations et est dans un certain état, cet état est lui aussi dans un alphabet fini , l'ensemble Q des états, il a différentes opérations possibles : lire et écrire dans la case pointée, il peut aussi changer d'état, il peux déplacer le pointeur vers la gauche ou la droite. Le programme c'est  : quoi faire quand on commence, que faire quand on a un couple état/lettre dans la case.\\\\\textbf{Définition : }Une MT est un octuplet (ensemble d'états(Q),$\Sigma$(alphabet d'entrée/sortie),$\Gamma$,lettre blanche (B), état initial(Q0), un état fini succès(Qoui), un ensemble d'état finaux échec(Qnon) et $\delta$ : la fonction de transition).\\\\\textbf{Définition : } Une configuration d'une MT M est un triplet (q,c,p) $\in$ Q * $\gamma$ exp{Z} x Z.\\\\\textbf{Définition : } Il existe une transition de la configuration (q,v,p) à la configuration (q',c',p') de M, notée \\(q,c,p |-(q',c',p')\\si$\delta$(q,c(p)) = (q',a,d)\\où $\forall$k$\in$Z c'(k)= a si k = p, c(k) sinon, et p'=  p-1 si d = <-, p si d= bas, et p+1 si d= ->\\\\\textbf{Remarque : }Dans une utilisation normale d'une MT le ruban est B presque partout. On préféreras noter uqv une configuration (q,c,p) telle que : u: ce qu'il y a de pas blanc avant la case, q l'état de la MT, et V ce qu'il y a après sur la bande.\\\\\textbf{Définition : } La configuration initiale de M sur l'entrée u $\in$ $\Sigma$* est la configuration q0u.\\\\\textbf{Définition} une configuration acceptante de M est une configuration UqouiV.\\\\\textbf{Définition : }une configuration de refus de M ets une configuration UqnonV.\\\\La machine s'arrete lorsqu'elle atteint un état d’arrêt , c’est a dire l'état acceptant qoui ou l'état de refus qnon.\\\\\textbf{Remarque : }On noteras |-n n transitions successive, |-* = union des transitions(|- 0 l'identité).\\\\\textbf{Définition : }Le langage L(M) d'une MT m est l'ensemble des mots acceptés : L(M) = {u$\in$ $\Sigma$* | q0 u |- * VQuoiW}.\\\\\textbf{Définition : } Un langage est récursivement énumérable s'il est le langage d'une MT M, ie L= L(M).\\\\\textbf{Définition : } Un langage L est récursif s'il est le langage d'un MT qui s'arrete sur toute entité.\\\\\textbf{Exemple : } Langage des palindrome : L{u $\in$ {a,b}* | u est un palindrome} 
\end{document}