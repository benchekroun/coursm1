









































































































































\documentclass{article}
\usepackage[utf8]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}


\title{Calculabilité et Complexité - Nicolas Ollinger}
\author{Alexandre Masson}
\date{15 Janvier 2013}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Fondements de l'informatique}le But du cours est de nous donner quelques éléments culturels pour comprendre comment certaines choses seront toujours valable dans 50 ans et pourquoi c'est de la science.\\\\Computability en Anglais , on s'intéresse à la propriété d’être calculable.\\\\Qu'est ce qui est calculable?\\\\ Complexité s’intéresse à la meilleur complexité que l'on peut obtenir avec un algorithme. Existe il des problèmes intrinsèquement plus complexes que d'autres (ex: tri , pas possible de faire mieux que O(nlog(n))).\\\\Il est possible ici de faire un parallèle entre Programmation et Algorithmique. Ces deux choses travaillent sur : comment trouver de programme (ou comment construire un programme qui résous un problème) et calculabilité et complexité détermine l'existence d'un programme pour résoudre un problème.\\\\thèse de Church-Turing(rien d'intuitif, quelque-soit le langage de prog, on ne pourra pas calculer plus de choses).\\\\Les programmes qui calculent des fonctions partielles , peuvent ne pas répondre à des problèmes.\\\\Un interprète, prend un programme et une donnée et renvoi le résultat du programme sur la donnée.Une fonction universelle existe dans tout modèle de calcul(Travaux de Alan Turing).\\\\Un programme qui affiche son propre code dans son exécution, existe dans tous les langages de programmation. Théorème de récurrence, pour toute fonction , il existe une fonction auto-référente( qui se prend elle même en paramètre) qui prend e code en paramètre et affiche son code. \\\\ il n'existe pas de programme qui prend un autre programme en paramètre et dit si celui-ci s’arrête  ou pas.\newpage
\section{Calculabilité}
\paragraph{Définition} Études des modèles de calcul et des propriétés qui sont indépendantes du modèle.\\\\On s'intéresse : 
\begin{itemize}
\item aux programmes vus à la fois comme : 
\begin{itemize}
\item chaîne de caractères (code source) : un mot sur un alphabet fini
\item un objet qui code une fonction (soit des chaînes -> les chaînes, soit des Entiers -> les Entiers).
\end{itemize}
\paragraph{Remarque}on confondra allègrement et sans scrupules les ensemble E*(ensemble de tous les mots d'un alphabet), N*(ensemble des couples d'entiers de taille*) , N ,... qui sont codables bijectivement et récursivement (codage et décodage calculables par un programme)  les uns en les autres.\\\\
\item problèmes de décision : problème auquel on répond par oui ou non, c'est un langage (donc un sous ensemble de E*).
\end{itemize}
\paragraph{Intuitivement}
Une fonction f est : E* -> E* partielle est calculable si il existe un programme tel que : $\forall$ x $\in$ $\sigma$ * .\\\\
Un problème de décision P $\subset$ $\sigma$ * est décidable si fp : x -> oui si p est x $\in$ P est calculable , non sinon.
\section{Motivation informelle(approche naïve)}Fixons un langage de programmation impératif IMP idéalisé. Code Source,entrée,sortie $\in$ UTF8*. Prenons eval(p,x) = y si les programme sur l'entrée x s'arrête en renvoyant y, $\perp$ sinon.\\\\$\phi$ p : $\sigma$ * -> $\sigma$ *\\$\phi$ (x) = eval(p,x).\\\\Question : Est ce que toute fonction est IMP-calculable? NON, il suffit de compter!\\\textbf{Prop : }Toutes les fonctions ne sont pas IMP-calculable.\\\textbf{Démonstration : }Comparons le nombre des fonctions et le nombre des programmes, $\sigma$ * est un ensemble infini dénombrable.\\$\sigma$ * -> $\sigma$ * n'est pas dénombrable.\\donc il existe des fonctions non IMP-calculable. $\sigma$ *  est dénombrable : il suffit d'énumérer par taille croissante et ordre lexicographique à taille fixée.\\\\$\sigma$ * -> $\sigma$ * n'est  \textsc{pas} dénombrable.\\\\Procédé de Cantor : \\\t par l'absurde , on suppose que $\sigma$ * -> $\sigma$ * est dénombrable : énumération($\phi$ i) tel que { $\phi$ i} = $\sigma$ * $\sigma$ * 
\paragraph{Remarque : }l'entrée est <p,x> codage dans la paire(p,x).
\paragraph{Proposition : }Il existe un programme universel U tel que $\forall$ p $\forall$ X U(<p,x>) = eval(p,x), il suffit de prendre pour U un interprète IMP codé en IMP.
\paragraph{Proposition  : }IMP-arrêt est IMP-indécidable.
\paragraph{Démonstration : }Par l'absurde. Supposons que IMP-arrêt soit IMP-décidable, idem qu'il existe un programme débug tel que $\phi$ debug (<p,x>) = {oui si $\phi$p(x) != $\perp$, NON sinon}.\\On construit un programme malicieux comme suit :  on lit X, on execute debug, si debug dis oui boucle infinie while 1 , sinon return , masi alors , $\phi$ malicieux(malicieux) répond oui si imp-arrêt dis non et non si imp arrête dis oui, donc ce programme ontredit IMP-arrêt CONTRADICTOIRE!!! donc IMP-arrêt n'est pas IMP-calculable.\\Comment utiliser ce résultats pour démontrer que d'autres problèmes sont indécidables
\paragraph{imp-arrêt}entrée : code source P.\\question : Est ce que $\phi$($\epsilon$) != $\perp$.\\\\On aimerais montrer que IMP-arrêt0 est lui aussi IMP-indécidable en montrant que IMP-arrêt est plus simple que IMP-arrêt0. On va construire un programme qui utilise IMP-arrêt0  pour résoudre imp-arrêt.\\\\

Est ce que $\phi$\_{p}(x) != $\perp$ \\\\On a montré que IMP-arrêt est indécidable on va dire que IMP-arrêt <=\_{imp} IMP-arrêt0.\\On va construire un programme qui utilise un programme qui résout IMP-arrêt0 pour résoudre IMP-arrêt. Dans IMP-arrêt, on a en entrée P et x, on doit manipuler P et x, pour contruire un programme P' qui va nourrir imp-arrêt0.\\\\Démonstration : Par l'absurde, on suppose qu'il existe un programme qui décide imp-arrêt0.\\\\On construit alors le programme suivant : \\\\Read Z;\\P:= $\pi$\_{1}(Z)\\X:= $\pi$\_{2}(Z)\\Q := le programme P où la première ligne [read Y] est remplacée par [read Y; Y := X];\\R := IMP-arrêt0(Q);\\write(R);\\\\Ce programme résout imp-arrêt, qui est imp-indécidable : CONTRADICTION. Donc IMP-arrêt0 est indécidable.\\\\Cette preuve utilise une technique d'évaluation partielle.\\\\\textbf{Proposition : } Il existe une fonction IMP-calculable s qui à <P,x> associe le code source d'un programme qui ignore son entrée et simule le programme P sur l'entrée x, c’est à dire : $\forall$ y, $\phi$s(<P,x>)(Y) = $\phi$p(x).\\\\\textbf{Proposition : } Il existe une fonction IMP-calculable s qui à <P,x> associe le code source d'un programme qui sur une entrée Y, simule le programme P sur l'entrée <X,Y>  : $\phi$s(<P,x>)(Y) = $\phi$p(<X,Y>). .\\\\\textbf{Démonstration : } Idem, mais remplacer [read Y] par [read Y, Y:= <X,Y>].\\\\Prop : il existe un programme IMP qui retourne son propre programme code source.\\\textbf{Démonstration : }\\Soit R le programme suivante : \\Read(Z);\\X:=$\pi$1(Z)\\Y := s'(<X,X>)\\write Y\\donc le programme s'(<R,R>) écrit son propre code source.\\\textbf{Bilan : }Ce qui précède ne dépend pas vraiment de IMP.\\Quelques principes sous-jacents :\begin{itemize}
\item dénombre de manière calculable les programmes;
\item possibilités d'enchainer, concaténer, composer des programmes.
\item existence d'un crochet <.,.> et de projection $\pi$1,$\pi$2 calculables.
\item existence d'un programme universel;
\item existence de fonctions d'évaluation partielle : s,s',...
\end{itemize}
La calculabilité s'intéresse aux propriétés des fonctions calculables qui sont indépendantes du modèles de calcul considéré
\section{Machines de Turing} Les MT sont le modèle de calcul de référence du cours. Il s'agit d'un modèle de machine mécanique abstrait.C'est le modèle de référence en complexité. A.M.Turing  : On computable numbers with an application to the Entscheidungproblem.1936
\subsection{Définitions} LE ruban est coupé en case, quantité finie d'information, on suppose qu'on a un alphabet fini qui nous permet d'écrire dans les cases du ruban, et le contenu d'un case c'est une lettre sur un alphabet fini.\\\\L’opérateur est une flèche qui pointe sur une case, il a le droit de mémoriser une quantité fini d'informations et est dans un certain état, cet état est lui aussi dans un alphabet fini , l'ensemble Q des états, il a différentes opérations possibles : lire et écrire dans la case pointée, il peut aussi changer d'état, il peux déplacer le pointeur vers la gauche ou la droite. Le programme c'est  : quoi faire quand on commence, que faire quand on a un couple état/lettre dans la case.\\\\\textbf{Définition : }Une MT est un octuplet (ensemble d'états(Q),$\Sigma$(alphabet d'entrée/sortie),$\Gamma$,lettre blanche (B), état initial(Q0), un état fini succès(Qoui), un ensemble d'état finaux échec(Qnon) et $\delta$ : la fonction de transition).\\\\\textbf{Définition : } Une configuration d'une MT M est un triplet (q,c,p) $\in$ Q * $\gamma$ exp{Z} x Z.\\\\\textbf{Définition : } Il existe une transition de la configuration (q,v,p) à la configuration (q',c',p') de M, notée \\(q,c,p |-(q',c',p')\\si$\delta$(q,c(p)) = (q',a,d)\\où $\forall$k$\in$Z c'(k)= a si k = p, c(k) sinon, et p'=  p-1 si d = <-, p si d= bas, et p+1 si d= ->\\\\\textbf{Remarque : }Dans une utilisation normale d'une MT le ruban est B presque partout. On préféreras noter uqv une configuration (q,c,p) telle que : u: ce qu'il y a de pas blanc avant la case, q l'état de la MT, et V ce qu'il y a après sur la bande.\\\\\textbf{Définition : } La configuration initiale de M sur l'entrée u $\in$ $\Sigma$* est la configuration q0u.\\\\\textbf{Définition} une configuration acceptante de M est une configuration UqouiV.\\\\\textbf{Définition : }une configuration de refus de M ets une configuration UqnonV.\\\\La machine s'arrete lorsqu'elle atteint un état d’arrêt , c’est a dire l'état acceptant qoui ou l'état de refus qnon.\\\\\textbf{Remarque : }On noteras |-n n transitions successive, |-* = union des transitions(|- 0 l'identité).\\\\\textbf{Définition : }Le langage L(M) d'une MT m est l'ensemble des mots acceptés : L(M) = {u$\in$ $\Sigma$* | q0 u |- * VQuoiW}.\\\\\textbf{Définition : } Un langage est récursivement énumérable s'il est le langage d'une MT M, ie L= L(M).\\\\\textbf{Définition : } Un langage L est récursif s'il est le langage d'un MT qui s'arrete sur toute entité.\\\\\textbf{Exemple : } Langage des palindrome : L{u $\in$ {a,b}* | u est un palindrome}.\\\\ \textbf{Définition}un problème est décidable si son langage est récursif.\\exemple : le problème de l'arret :\\ l'entrée : une MT M et u un mot u $\in \Sigma^{*}$. Question Est que $\Phi_{M}(U) != \perp$?\\\\Langage associé : K = {wM,u | $\Phi_{M}(u) != \perp$}
\paragraph{Définition}
Une fonction partielle f: $\Sigma* -> \Sigma*$ est calculable si il existe une MT M qui calcule F, c'ets a dire que $\forall u \in \Sigma*$ \begin{itemize}
\item $q_{0} \vdash^{*} vq_{oui}f(u) si f(u) != \perp$
\item $\neg q_{0} \vdash^{*} vq_{oui}f(u) si f(u) = \perp$
\end{itemize}
\paragraph{Proposition}
Un langage L $\subseteq \Sigma^{*}$ tes récursif si et seulement si L est récursivement énumérable et L est complémentairement récursivement énumérable \\\\\textbf{Remarque : }L est co-r.e signifie $\Sigma^{*}\backslash L$ est r.e.
\paragraph{Démonstration} \textbf{dans le sens $\Rightarrow$ }L est récursif donc il existe une MT M totale telle que L(M) = L.\\L est r.e car M reconnaît L.\\ L est Co-r.e car M', copie de M où $q_{oui}$ et $q_{non}$ sont échangés, reconnais $\Sigma^{*}\backslash L$\\\\
\textbf{Dans le sens $\Leftarrow$ } Soient M une MT qui reconnaît ML et N une MT qui reconnaît $\Sigma^{*}\backslash L$, on construit une MT Z qui , sur une entrée u, simule en parallèle M et N sur l'entrée u. Si M s’arrête alors Z répond oui. Si N s’arrête alors Z répond non. Z est totale et reconnais L.\\\\\textbf{Exercice : } Montrons que L ets récursif si et seulement si $\chi_{L}$ est calculable , où $\forall u \in \Sigma^{*} \chi_{L}(u) = ${OUI si u $\in$ L et NON sinon
\section{Thèse de Chruch-Turing-Kleene}
\begin{itemize}
\item 1936 A.Turing définit le calcul/ par les MT. <- complètement mécanique
\item 1936 A.Church définit le calcul par la $\lambda-definissibilité$, i.e le $\lambda-calcul$ <- modèle fonctionnel.
\end{itemize}
\paragraph{Thèse} La notion intuitive de ce qui est calculable correspond exactement à la notion de fonction calculable par MT.
\paragraph{Idée : } essayer de construire d'autre modèle de calcul "raisonnables" : la notion de calculables coïncide toujours (en tout cas de  1936 à 2013).
\section{la machine universelle} 
\paragraph{Proposition} IL existe une machine de Turing U telle que :\\ $\forall M\forall u$  $\Phi_{U}(<M,u>) = \Phi_{M}(u)$ 
\paragraph{Proposition} La fonction STEP suivant est calculable. \\\\$\forall M\forall u\in \Sigma^{*} \forall k \in N$ : \\ STEP(<M,u,K>) = 
\begin{itemize}
\item TERMINÉ(q,v) si M sur l'entrée u arrête avant k étapes avec sortie v dans l'état q
\item ENCOURS sinon.
\end{itemize}
\paragraph{Principe de fonctionnement de U} Sur l'entrée <M,u> U doit simuler le calcul de M sur l'entrée u. Simuler M c'est lire le ruban , écrire, déplacer la tête , modifier l'état.\\U organise sa mémoire, son ruban , en zones, pour coder \begin{itemize}
\item l'état de M
\item le ruban de M
\item la table de transitions de M
\end{itemize}
%penser a rajouter l'image de la mémoire de U qui décrite 29 janvier : 16h36
\paragraph{} U se contente de chercher l'état et la lettre correcte dans la table des transition, de les remplacer et de déplacer le marqueur.Ajouter des détails techniques pour initialiser et arrêter le calcul.\\STEP fonctionne pareil en limitant le nombre de pas de simulation à k.
\section{Indécidabilité}
\paragraph{Proposition} Il existe des langages non récursifs. Preuve par dénombrement  : Il y a $\omega$ MT et $2^{\omega}$ fonctions partielles de $\Sigma^{*} -> \Sigma^{*}$.\\\\ K = { <M,u> | $\Phi_{M}(u) != \bot$}
\paragraph{Remarque : } K est r.e il suffit d'utiliser U pour tester $\Phi_{M}(u)$.
\paragraph{Théorème de l’arrêt} K n'est pas récursif, ie le pb de l’arrêt n'est pas décidable.
\paragraph{Démonstration} Supposons qu'il existe une MT H telle que \\$\forall M\forall u$   $\Phi_{H}(<M,U>)=$
\begin{itemize}
\item OUI si $\Phi_{M}(u) \neq \bot$
\item NON si $\Phi_{M}(u) = \bot$
\end{itemize}
On diagonalise H en construisant une MT qui s'appelle D(comme diagonale) qui sur l'entrée M (où M est le code d'une machine) : 
\begin{itemize}
\item exécuter H sur l'entrée <M,M>
\item si H à répondu OUI, on boucle
\item si H a répondu NON , on s'arrête.
\end{itemize}
$\forall M, \Phi_{D}(M)$ =  { $\bot$ si $\Phi_{M}(M) \neq \bot$ , arrêt  si $\Phi_{M}(M) = \bot$}\\\\Donc , si L= D :  $\Phi_{D}(D)$ =  { $\bot$ si $\Phi_{D}(D) \neq \bot$ , arrêt  si $\Phi_{D}(D) = \bot$  : CONTRADICTION !!!\\
Donc H n'existe pas, K n'est pas récursif, K n'est pas co-r.e.
\paragraph{Théorème de Rice} Soit P une propriété non triviale des fonctions partielles f: $\Sigma * -> \Sigma *$.\\L'ensemble des machines de Turing qui calculent une fonction qui satisfait P n'est pas récursif. P sélectionne parmis les fonctions partielles un sous-ensemble, non-triviale, indique qu'il existe deux fonction f et g différentes telles que P(f) est vrai et P(g) est faux. { M | P($\Phi_{M}$)} n'est pas récursif.\\exemple de propriété : \begin{itemize}
\item l'ensemble des fonctions totales
\item l'ensemble des fonctions définies nulle part
\item etc...
\end{itemize}

\paragraph{}
\begin{center}
\date{5 Février 2013}
\end{center}
Pour toute propriété non triviale sur les fonctions partielles savoir si une MT calcule une fonction qui satisfait est indécidable : cette fonction est triviale , si il existe une fonction f qui la satisfait, et une fonction g : $f \neq g$ qui ne la satisfait pas. Exemple :
\{ M | P($\Phi_{M}$)\} n'est pas récursif. \{ $ M | \phi_{M} \neq \bot$\}\\
\begin{center}
 K = \{ <M,x> | $\Phi_{M}(x) \neq \bot$ \}
\end{center}  
\paragraph{Démonstration} Par l'absurde, supposons qu'il existe une propriété non-triviale P calculable par MT $T_{P}$. soit $\bot$ une fonction définie nulle part. Supposons sans perte de généralité, que $\bot \notin$ P et soit S une MT telle que $\Phi_{S} \in$ P.\\\\On construit une machine de Turing F comme suit :
\begin{itemize}
\item Sur l'entrée <M,x>
\begin{itemize}
\item Soit T le codage de la MT suivante : 
\begin{itemize}
\item Sur l'entrée y : 
\begin{itemize}
\item simuler M sur l'entrée x.
\item si M s’arrête , on simule S sur l'entrée y
\item si S s’arrête, on s’arrête.
\end{itemize}
\end{itemize}
\item Simule $T_{P}$ sur l'entrée T
\begin{itemize}
\item Si $T_{P}$ répond OUI, accepter <M,x>
\item Si $T_{P}$ répond NON, rejeter <M,x>
\end{itemize}
\end{itemize}
\end{itemize}
F est totale.\\\\
$\Phi_{F}(<M,x>) =$ \{ OUI si $T_{P}(T)$ = OUI, ie $si \Phi_{M}(x) \neq \bot$ \\ et NON si $T_{P}(T)$, ie si $\Phi_{M}(x)$ = $\bot$\}\\F résout le problème de l’arrêt ! CONTRADICTION\\\\

Les problèmes indécidables sont légion : 
\begin{itemize}
\item le typage au second ordre du $\lambda$-calcul;
\item mortalité des produits de matrices carrées
\item problème du mot pour les groupes finiment engendrés.
\item exemple : existence d'une solution entière à une équation polynomiale à coefficient entiers ($10^{ème}$ problème de Hilbert).
\item Pavabilité du plan par un jeu de tuiles de Wang (tuiles divisées en quater avec des couleurs au coins, pas le droit de les tourner , et on les collent avec deux couleurs identiques aux arrêtes adjacentes);
\begin{itemize}
\item entrée : famille de tuiles de Wang T $\subseteq \Sigma^{4}$
\item Question : T pave-t-il le plan , ie, $\exists c : Z^{2} -> T$ telle que les contraintes soient satisfaites.
\end{itemize}
\end{itemize}

\paragraph{Problème de correspondance de Post} 
\begin{itemize}
\item entrée : $u_{1}$, $u_{2}$ , ..., $u_{n}$, $v_{1}$, $v_{2}$,...,$v_{n} \in \Sigma^{*}$
\item question : $\exists (ik)$ $u_{1}$, $u_{2}$ , ..., $u_{n}$ =  $v_{1}$, $v_{2}$,...,$v_{n}$ ?
\end{itemize}
\section{Interlude}
\paragraph{Définition} Une machine linéairement bornée (MTLB) est une MT qui s'interdit d’écrire sur B. $ \forall q,q',a,d$  $\sigma (q,B) = (q',a,d)$ -> a  = B car on ne peux pas écrire sur blanc.
\paragraph{Proposition} L'arret des MTLB est décidable.
\paragraph{Démonstration} On construit le graphe fini des configuration accessibles à partir de l'entrée x pour la machine M. Il y a environ $|Q|*(|x|+2)*|\Gamma|^{|x|}$\\\\\textbf{$\exists_{MTLB}$}
\begin{itemize}
\item entrée : M une MTLB
\item question : Existe-t-il une entrée x acceptée par M?\\
\end{itemize}
\textbf{Proposition} $\exists_{MTLB}$ est indécidable\\
\textbf{Démonstration} Par l'absurde, on suppose que $\exists_{MTLB}$ est décidable, et on construit un programme qui résoud l’arrêt des MT.\\IL s'agit étant donnés une MT M et une donnée x, de calculer une MTLB f(<M,x>) qui accepte une entrée si et seulement si le MT M  s’arrête sur l'entrée x. Notre MTLB est un vérifieur/parseur/accepteur de trace de MT : il considère son entrée comme une suite de configuration valide de M qui commence pas  $q_{0}^{x}$ et termine par une configuration d'arrêt : \\
BB\#$q_{0}x1x2...xn$\# ... \# ...\#BB \\\\
\begin{center}
$\Sigma ' = Q_{M} \cup \Gamma_{M} \cup$\{\#\}\\
$\Gamma ' = \Sigma ' \cup $\{B\} $\cup$ alphabet Entouré
\end{center}
\textbf{Principe de fonctionnement de la MTLB : }
\begin{itemize}
\item vérifier que l'entrée commence par \#$q_{0}x1x2...xn$\#
\item vérifier que l'entrée termine par \# ... $q_{OUI}$...\#
\item pour chaque paire successive \#u\#v\# avec $ u,v \in \Sigma'^{*}\backslash$ \{\#\}7
\begin{itemize}
\item vérifier que $u|-_{M}v$ en faisant des aller retours en marquant les position avec l'alphabet entouré.
\end{itemize}
\end{itemize}
MPCP est la variante de PCP dnas laquelle on est obligé de commencer par le premier domino ($i_{1} = 1$).\\\textbf{Théorème} MPCP est indécidable\\\\\textbf{Démonstration} Idée : comme pour $\exists_{MTLB}$ on va construire un reconnaisseur de trace de MT. <M,x> |----> jeu de dominos T(M,x) tel que T(M,x) à une solution si et seulement si $\Phi(x)\neq\bot$ et même mieux la solution de T(<M,x>) écrit une trace de M sur l'entrée x.
\paragraph{Voici les dominos de T(<M,x>)}
\textbf{INSERER ICI LES IMAGES DU TABLEAU}
T(<M,x>) admet pour solutions les traces acceptables de M sur l'entrée x. MPCP est indécidable
\end{document}