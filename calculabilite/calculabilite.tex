\documentclass{report}
\usepackage[utf8]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}


\title{Calculabilité et Complexité - Nicolas Ollinger}
\author{Alexandre Masson}
\date{15 Janvier 2013}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Fondements de l'informatique}le But du cours est de nous donner quelques éléments culturels pour comprendre comment certaines choses seront toujours valable dans 50 ans et pourquoi c'est de la science.\\\\Computability en Anglais , on s'intéresse à la propriété d’être calculable.\\\\Qu'est ce qui est calculable?\\\\ Complexité s’intéresse à la meilleur complexité que l'on peut obtenir avec un algorithme. Existe il des problèmes intrinsèquement plus complexes que d'autres (ex: tri , pas possible de faire mieux que O(nlog(n))).\\\\Il est possible ici de faire un parallèle entre Programmation et Algorithmique. Ces deux choses travaillent sur : comment trouver de programme (ou comment construire un programme qui résous un problème) et calculabilité et complexité détermine l'existence d'un programme pour résoudre un problème.\\\\thèse de Church-Turing(rien d'intuitif, quelque-soit le langage de prog, on ne pourra pas calculer plus de choses).\\\\Les programmes qui calculent des fonctions partielles , peuvent ne pas répondre à des problèmes.\\\\Un interprète, prend un programme et une donnée et renvoi le résultat du programme sur la donnée.Une fonction universelle existe dans tout modèle de calcul(Travaux de Alan Turing).\\\\Un programme qui affiche son propre code dans son exécution, existe dans tous les langages de programmation. Théorème de récurrence, pour toute fonction , il existe une fonction auto-référente( qui se prend elle même en paramètre) qui prend e code en paramètre et affiche son code. \\\\ il n'existe pas de programme qui prend un autre programme en paramètre et dit si celui-ci s’arrête  ou pas.\newpage
\section{Calculabilité}
\paragraph{Définition} Études des modèles de calcul et des propriétés qui sont indépendantes du modèle.\\\\On s'intéresse : 
\begin{itemize}
\item aux programmes vus à la fois comme : 
\begin{itemize}
\item chaîne de caractères (code source) : un mot sur un alphabet fini
\item un objet qui code une fonction (soit des chaînes -> les chaînes, soit des Entiers -> les Entiers).
\end{itemize}
\paragraph{Remarque}on confondra allègrement et sans scrupules les ensemble E*(ensemble de tous les mots d'un alphabet), N*(ensemble des couples d'entiers de taille*) , N ,... qui sont codables bijectivement et récursivement (codage et décodage calculables par un programme)  les uns en les autres.\\\\
\item problèmes de décision : problème auquel on répond par oui ou non, c'est un langage (donc un sous ensemble de E*).
\end{itemize}
\paragraph{Intuitivement}
Une fonction f est : E* -> E* partielle est calculable si il existe un programme tel que : \forall x \in \sigma * .\\\\
Un problème de décision P \subset \sigma * est décidable si fp : x -> oui si p est x \in P est calculable , non sinon.
\section{Motivation informelle(approche naïve)}Fixons un langage de programmation impératif IMP idéalisé. Code Source,entrée,sortie \in UTF8*. Prenons eval(p,x) = y si les programme sur l'entrée x s'arrete en renvoyant y, \perp sinon.\\\\\phi p : \sigma * -> \sigma *\\\phi (x) = eval(p,x).\\\\Question : Est ce que toute fonction est IMP-calculable? NON, il suffit de compter!\\\textbf{Prop : }Toutes les fonctions ne sont pas IMP-calculable.\\\textbf{Démonstration : }Comparons le nombre des fonctions et le nombre des programmes, \sigma * est un ensemble infini dénombrable.\\\sigma * -> \sigma * n'est pas dénombrable.\\donc il existe des fonctions non IMP-calculable. \sigma *  est dénombrable : il suffit d'énumérer par taille croissante et ordre lexicographique à taille fixée.\\\\\sigma * -> \sigma * n'est  \textsc{pas} dénombrable.\\\\Procédé de Cantor : \\\t par l'absurde , on suppose que \sigma * -> \sigma * est dénombrable : énumération(\phi i) tel que { \phi i} = \sigma * \sigma * 
\paragraph{Remarque : }l'entrée est <p,x> codage dans la paire(p,x).
\paragraph{Proposition : }Il existe un programme universel U tel que \forall p \forall X U(<p,x>) = eval(p,x), il suffit de prendre pour U un interprète IMP codé en IMP.
\paragraph{Proposition  : }IMP-arrêt est IMP-indécidable.
\paragraph{Démonstration : }Par l'absurde. Supposons que IMP-arrêt soit IMP-décidable, idem qu'il existe un programme débug tel que \phi debug (<p,x>) = {oui si \phip(x) != \perp, NON sinon}.\\On construit un programme malicieux comme suit :  on lit X, on execute debug, si debug dis oui boucle infinie while 1 , sinon return , masi alors , \phi malicieux(malicieux) répodn oui si imp-arret dis non et non si imp arrete dis oui, donc ce programme ontredit IMP-Arret CONTRADICTOIRE!!! donc IMP-ARRET n'est pas IMP-calculable.\\Comment utiliser ce résultats pour démontrer que s'autres problèmes sont indécidables
\paragraph{imp-arret0}entrée : code source P.\\question : Est ce que \phi(\epsilon) != \perp.\\\\On aimerais montrer que IMP-arret0 est lui aussi IMP-indécidable en montrant que IMP-arret est plsu ssimple qye IMP-arret 0. On va construire un programme qui utilise IMP-arret0  pour résoudre imp-arret.
\end{document}