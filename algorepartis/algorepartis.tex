\documentclass{article}
\usepackage[utf8]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package


\title{Algorithmes Répartis - Jean-Michel Couvreur}
\author{Alexandre Masson}
\date{14 Janvier 2013}

\begin{document}
\maketitle
\newpage
\paragraph{Sujets traités}
\begin{itemize}
\item Modele synchrone
\item 
\end{itemize}
\paragraph{Évaluation}
\begin{itemize}
\item Controle continu
\begin{itemize}
\item controle sur table
\item mini-projet
\end{itemize}
\item Controle terminal
\begin{itemize}
\item un controle sur table
\item la nature du sujet sera développée en cours
\end{itemize}
\end{itemize}

\section{Modèle Synchrone}
\paragraph{}Processus sont attachés à des noeuds d'un graphe orienté  et communique par des messages.\\\\Graphe G  = (V,E, n = |V|
\begin{itemize}
\item outnbr, innbr
\item distance(i,j) taille du plus court chemin de i à j
\item diametre
\end{itemize}
M : alphabet des messages plus false pour rien.\\\\ pour tout i dans V, un processus est donnée par
\begin{itemize}
\item States: ensemble d'états
\item start : états initiaux
\item msgs : states x out-nbrs -> M U {false}
\item trans: ensemble des transitions
\end{itemize}
Exécution d'un tour ; 
\begin{itemize}
\item appliquer msgs pour déterminer les messages à envoyer
\item envoyer et recevoir les messages, 
\item Appliquer trans , pour déterminer l'état suivant.
\end{itemize}

\paragraph{Remarques}
\begin{itemize}
\item pas de restriction sur la durée des calculs locaux,
\item Déterministes,
\item on peux définir des "états d’arrêt",
\item Plus tard nous examinerons quelques problèmes : 
\begin{itemize}
\item temps de démarrage variable
\item défaillance
\item choix aléatoires
\end{itemize}
\end{itemize}

\paragraph{Exécution}
\begin{itemize}
\item une exécution est un objet mathématique servant à décrire comment un algorithme fonctionne.
\item Définition: 
\begin{itemize}
\item un état global
\item Messages
\item exécution : C0,M1,N1,C1,M2,N2,...
\begin{itemize}
\item C* : sont des états globaux
\item M*  : sont les messages envoyés
\item N*  : sont les messages reçus
\item Séquence infinie (mais on peut considérer des préfixes finis)
\end{itemize}
\end{itemize}
\end{itemize}
\newpage
\section{Problème de l'élection d'un leader}
\begin{itemize}
\item Réseau de processus
\item Vous voulez distinguer un processus , le leader.
\item Finalement, exactement un processus sera désigné leader
\item Motivation : le leader peux prendre en charge:
\begin{itemize}
\item les communications
\item coordination des traitements des données (par exemple; dans les protocoles de validation)
\item Allocation de ressources
\item etc...
\end{itemize}
\end{itemize}
\paragraph{Cas simple l'anneau}
\begin{itemize}


\item Variantes : \begin{itemize}
\item bidirectionnel ou unidirectionnel
\item taille de l'anneau n connu ou inconnu
\end{itemize}
\end{itemize}

\paragraph{Nous avons besoin de qqc de plus}
\begin{itemize}
\item besoin de distinguer les processus
\item supposons un UID , s'il connaît
\item chaque processus démarre en stockant son pid
\item il sont comparable et pouvoir faire de l'arithmétique simple dessus est un plus
\item dans le réseau tous les identifiants sont différents
\end{itemize}
\paragraph{Un algorithme}
\begin{itemize}
\item autors : LeLann , Chang,Roberts
\item hypothèse 
\begin{itemize}
\item comm unidirectionnelle
\item les proc ne connaissent pas n
\item comparaison d'UID seulement
\end{itemize}
\item Idée: 
\begin{itemize}
\item chaque processus envoi son uid dans un message, à relayer étape par étape, autour de l'anneau.
\item le proc compare l'id reçu avec le sien , et envoi a son voisin le plus grand des deux entre le sien et celui reçu.
\end{itemize}
\end{itemize}

\paragraph{Preuve , complexité, terminaison}
\begin{itemize}
\item M, l'alphabet de messages : {UID}
\item état : valeur des variables :
\begin{itemize}
\item u : a pour valeur son pid
\item send, son pid ou false
\it status : ?  ou leader, initialement ?
\end{itemize}
\item start : défini par l'init des variables
\item msgs : transmet la valeur send à son voisin
\item trans : défini par le pseudo-code : 
\begin{itemize}
\item if incomming = v, a UID, then
\item \t case :
\item  v >  u  : send := v;
\item  v = u  : status := leader
\item  v<u : no-op
\item \t endcase
\end{itemize}
\end{itemize}

\paragraph{Réduire le nombre de communication}
\begin{itemize}
\item autor: Hirschberg,Sinclair
\item hypothèse : 
\begin{itemize}
\item bidirectionnel
\item les processus ne connaissent pas n
\item comparaisons d'id seulement
\end{itemize}
\item Idée : 
\begin{itemize}
\item Stratégie du doublement
\item Chaque processus envoie son UID dans les deux sens, à des distances de plus en plus grandes (successivement deux fois plus grande à chaque fois)
\item phase aller : un jeton est ignoré si il atteint un noeud dont l'uid est plus grand
\item phase retour : tout le monde passe le jeton
\it un processus débute la phase suivante que si ses deux jetons reviennent.
\it le processus qui reçoit son propre jeton dans la phase aller est l'élu.
\end{itemize}
\end{itemize}

\paragraph{Élection d'un leader}
\begin{itemize}
\item Hypothèse
\begin{itemize}
\item UID avec comparaisons.
\item pas d'hypothèse sur la répartition des UID
\item les processus connaissent un majorant du diamètre
\end{itemize}
\end{itemize}

\section{14 Février 2013}

\paragraph{défaillance de processus} défaillance byzantine : chaque processus envoie sa valeur, le cas de l’arrêt fonctionne, nb rang = nb panne +1. byz: un menteur au moment du choix, va envoyer au suivant une mauvaise valeur .
\paragraph{collecte d'information exponentielle} valeur transmise le long d'un réseau en forme d'arbre. la première couche correspond au résultats reçu à l'étape numéro 1., le seconde correspond à la 2eme étape. le dernier chiffre du numéro marqué au dessus de la "feuille" c’est le dernier processus à avoir envoyer le message reçu. on peut ainsi remonter le chemin parcouru par le message.\\\\Chaque processus utilise la même structure d'arbre.\\les noeuds sont étiquetés par des valeurs\\\textbf{initialement} les têtes sont étiquetées par la valeur du noeuds\\\textbf{round r> 1} \begin{itemize}
\item envoyer le niveau r-1 à tous nœuds (soi même aussi)
\item utiliser les messages reçu pour étiqueter le niveau r
\item si pas de message utiliser $\bot$
\end{itemize}
\paragraph{règle de choix pour le cas de la panne d'arret : }
\begin{itemize}
\item triviale
\item on prend toutes les étiquettes de l'arbre
\item si un seul élément , on le prend
\item sinon on prend par défaut $v_0$
\end{itemize}
\paragraph{preuve et complexité}
\begin{itemize}
\item preuve  :  il y aura toujours un moment ou il n'y a pas de panne
\item complexité : nombre de panne +1 rounds, il envoi a tous ces voisins
\item complexité en nombre de message  : n-1 * nombre de pannes
\item défaut:  nombre de feuilles peut croître exponentiellement
\end{itemize}

\subsection{Algorithmes:  pannes byzantines}
\begin{itemize}
\item conditions : 
\begin{itemize}
\item accord : pas deux processus sans panne décide différemment
\item si tous les processus sans panne une valeur identique alors elle est choisie par tous les processus sans panne
\item Terminaison : tous les processus sans panne font un choix
\end{itemize}
\item EIG algorithme utilise : 
\begin{itemize}
\item un abre
\item f+1 rounds
\item n > 3f
\end{itemize}
\end{itemize}

\paragraph{mauvais exemple} 3 processus, 1 panne
supposons n > 3F : \\nouvelle règle de décision : 
\begin{itemize}
\item notons val(x) , la valeur du nœud x de l'arbre.
\item redécorer l'arbre 
\begin{itemize}
\item parcours de bas en haut pour trouver la valeur la plus fréquente.
\end{itemize}
\end{itemize}
\newpage
\date{18 Février 2013}
\section{Modèles asynchrones}
\subsection{réseaux asynchrones}
\paragraph{send/recv de  message}
Graphe G = (e,v), processus associé à chaque noeud et, un canal associé à chaque arc.\\\\\textbf{processus} interface utilisateur : inv, resp.\\problème spécifié en terme de trace autorisées au niveau utilisateur.
\paragraph{Canaux} différnets types de canaux : FIFO fiable, garantie fiable : perte, duplication, pas d'ordre.\\Peut ^etre définie comme une fonction sur un message d'entrée vers les messages de sortie. \\intégrité : préserve le message\\pas de perte\\pas de duplication\\respecte l'ordre.\\\\\textbf{broadcast et multicast} FIFO fiables enttre chaque noeud\\différents processus peuvent recevoir de différents émetteurs , mais sans contrainte d'ordre.
\subsection{Algorithmes sur des réseau asynchrones}
\paragraph{}Supposons que des FIFO fiables.
\begin{itemize}
\item Élection sur un anneau
\item idem sur un réseau
\item arbre couvrant minimum
\end{itemize}

\paragraph{} hypothèse : G est un anneau , unidirectionnel ou bidirectionnel, nom pour les voisins , uids\\\\ Il stocke ses messages dans sa fifo locale et attend que le canal soit libre pour envoyer.
\paragraph{Algorithme de Peterson} Baser sur la notion de phases . \\ Un processus est actif ou passif, les processus ne fond que relayer les messages\\Dans chaque phase la moitié des processus actif devient inactif, ainsi l’élection ne prend au plus n log n phases.\\\\\textbf{Phase 1 : } Envoyer UID de deux prédécesseurs, reste actif si l'uid du milieu est max.\\v autrement dit, chaque processus attend de recevoir les uids de ses deux prédécesseurs, ainsi , il envoi son uid au suivant, et soit les trois uids reçus, si celui du milieu n'est pas le max des trois, alors la processus passe en inactif(relay) et ne fera que passer des messages. Sinon, il prend l'uid du milieu et reste actif.\\

\section{4 mars 2013}
\subsection{Synchroniseurs}
on prend un algo sync et on veux le faire tourner dans un env async. simuler les algo sync en async , mise en place de synchroniseurs. On part d'un graphe non orient, on suppose qu'on a l'algo sync qui résout le pb. Un noeud va effectuer l'étape k quand tous les autre sauront finis l'étape k-1.\\Le principe : on introduit un synchroniseur, il attend la réponse des états dans les étapes, pour dire , c'est bon passez à la suite. le processus synchroniser , répartis dans tous les processus doit s'occuper de l'envoi/recv des messages. propriétés attendues : well formed : envoi bon messg au bon moment, cycle de vie, après avoir reçu mesg round r, passer au round r+1. Les messages sont envoyés au serveur et renvoyé par le serveur.\\\\ il y a aussi l'aspect local, chaque processus attend les message de rand R de tous ces voisins avant de passer à l'étape r+1, et par relation de parallélisme, on peux dans un comportement décaler tous les messages de rang r+1 derrière les message de rang r, afin de retrouver le même comportement que dans le global, car tous le messages de rang r++1 ne seront utilisées qu’après que tous les processus soient arrivés au rang r+1. En réalité, on a une interface de synchro locale qui est créée par utilisateur, l'utilisateur, envoie tous les mesg qu'il doit envoyer à cette interface. Cet interface est connectée aux interfaces des utilisateurs voisins. Chaque interface envoi les mesg de son utilisateur, et attend la réponses de TOUS ses voisins pour rendre les messages reçu à l'utilisateur. \\\\Safe Mode : on envoi un message, et on attend ceux de nos voisins,  mais même si on a tout reçu, on attend de recevoir des ack pour tous nos mesg envoyés pour passer en "safe" et passer au round suivant.

\section{18 Mars 2013}
\subsection{Horloge}  
\paragraph{Qu'est ce qu'une horloge}
\paragraph{Applications}
\paragraph{Temps logiques faibles et horloges vectorielles}
Savoir qu'un événement est après un autre, rapport de cause-effet , ceux qui ne sont pas dépendants, sont parallèle. \\Trois aspect : il simplifie la programmation dans des réseaux asynchrones, Réaliser un ordre total sur tous les événements, chacun des processus connait sont ordre par rapport aux autres.Objectif: associé à chaque event une valeur d'horloge, e.g global snapshot(photo sdu système).\\\\\textbf{localtime} : On considère un système send/recv . quelles sont les propriété quelle doit conservés.
\begin{itemize}
\item deux events distincts doivent avoir des valeurs d'horloge distinctes, indépendance des events
\item les events doivent respecter le temps
\item ltime(send) <ltime(recv) pour ordre logique
\item si on se donne une date, le nombre d'event avant la date doit etre fini. quand le système évolue, le temsp avance, il ne converge pas vers un date , il  avance vers l'infini et au-delà
\end{itemize}

\paragraph{} chaque processus va maintenir une valeur d'horloge unsigned int, init à 0, on indique ensuite comment on associe a chaque élément une valeur, à chaque fois qu'un processus execute un process local, il incrémente son horloge, quand il send un mesg, il increment sa valuer et il envoie dans le mesg sa valeur d'horloge, et quand le process  recoit un mesg, il a sa propre valeur d'horloge, et reçoit celle du voisin qui lui a envoyer le message, il prend la plus grande des deux +1 , pour nouvelle horloge.\\\\pour mettre en place un ordre total , on tiens comptes d'un couple(pid,valeur d'horloge), on le definit de manière lexico-graphique, d'abord le time, ensuite le pid.\\evenemtn ltime, uniques\\les evenements incrementent le temps, non-zero.

\paragraph{Welch's algorithm} Question : et si il y a déjà des horloges?, on veux utiliser ces horloges pour faire du temps logique.\\Chaque process a sa propre horloge, quand il y a un veent local, on regarde sa propre horloge et c'ets celle la que l'on donne. Quand on reçoit un mesg , on reçoit un mesg avec un date, le process attend que son horloge locale soit plus grande que la date recue. Il recoit le mesg dans sa fifo et ne l'accepte que si son horloge est arrivée et à dépassée la date envoyée avec le message

\paragraph{Banque} dans le système , chaque banquier possède les dates à laquelle il doit indiquer à un serveur combien de pognon il possède, quand arrive la date, il collecte l'argent qu'il a localement, et il a  besoin de calculer l'argent qui à été envoyé, il v attendre des autres processus des mesg avec les dates à laquelle le pognon à été envoyé, il va calculer l'argent qu'il a dans ses compte et calculer combien il a reçu à des dates antérieurs à la date d'envoi. le processus envoi un infinité de messages à d'autres, même avec 0 comme valeur de pognon.

\paragraph{Global snapshot} généralisation du banking system, on va avoir une vision globale du système\\ simuler machine a états, il reçoit des événements, il les mets dnas une file, et les executent dans l'ordre, avant d'exécuter un event r, il faut etre sur de ne pas recevoir un event  n< r, pour cela, on attend encore une fois que l'horloge locale passe la date r.
\subsection{horloge vectorielle} 
\paragraph{} on a envie de def un ordre sur des évents, mais pas forcement total, on peut comparer des events sur le même processus, et ceux appartenant au même envoie de message, mais les autres on ne peux pas. au lieu d'avoir une valeur d'horloge par processus on garde un vecteur d'horloge , soit mon horloge plus ma vision locale des horloges des autres processus. quand il envoie un message, il incrémente sa valeur, quadn il recçoit , il incrémente sa valeur a lui de la valeur maximum entre le max du vecter reçu +1 et la sienne +1, puis met a jours ses valeurs connues des autres processus , avec a chaque fois le maximum. Avec ce système là , on obtient l'ordre obtenu avec l'ordre total et l'ordre à l'execution.
\end{document}
