\documentclass{article}
\usepackage[utf8]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package


\title{Algorithmes Répartis - Jean-Michel Couvreur}
\author{Alexandre Masson}
\date{14 Janvier 2013}

\begin{document}
\maketitle
\newpage
\paragraph{Sujets traités}
\begin{itemize}
\item Modele synchrone
\item 
\end{itemize}
\paragraph{Évaluation}
\begin{itemize}
\item Controle continu
\begin{itemize}
\item controle sur table
\item mini-projet
\end{itemize}
\item Controle terminal
\begin{itemize}
\item un controle sur table
\item la nature du sujet sera développée en cours
\end{itemize}
\end{itemize}

\section{Modèle Synchrone}
\paragraph{}Processus sont attachés à des noeuds d'un graphe orienté  et communique par des messages.\\\\Graphe G  = (V,E, n = |V|
\begin{itemize}
\item outnbr, innbr
\item distance(i,j) taille du plus court chemin de i à j
\item diametre
\end{itemize}
M : alphabet des messages plus false pour rien.\\\\ pour tout i dans V, un processus est donnée par
\begin{itemize}
\item States: ensemble d'états
\item start : états initiaux
\item msgs : states x out-nbrs -> M U {false}
\item trans: ensemble des transitions
\end{itemize}
Exécution d'un tour ; 
\begin{itemize}
\item appliquer msgs pour déterminer les messages à envoyer
\item envoyer et recevoir les messages, 
\item Appliquer trans , pour déterminer l'état suivant.
\end{itemize}

\paragraph{Remarques}
\begin{itemize}
\item pas de restriction sur la durée des calculs locaux,
\item Déterministes,
\item on peux définir des "états d’arrêt",
\item Plus tard nous examinerons quelques problèmes : 
\begin{itemize}
\item temps de démarrage variable
\item défaillance
\item choix aléatoires
\end{itemize}
\end{itemize}

\paragraph{Exécution}
\begin{itemize}
\item une exécution est un objet mathématique servant à décrire comment un algorithme fonctionne.
\item Définition: 
\begin{itemize}
\item un état global
\item Messages
\item exécution : C0,M1,N1,C1,M2,N2,...
\begin{itemize}
\item C* : sont des états globaux
\item M*  : sont les messages envoyés
\item N*  : sont les messages reçus
\item Séquence infinie (mais on peut considérer des préfixes finis)
\end{itemize}
\end{itemize}
\end{itemize}
\newpage
\section{Problème de l'élection d'un leader}
\begin{itemize}
\item Réseau de processus
\item Vous voulez distinguer un processus , le leader.
\item Finalement, exactement un processus sera désigné leader
\item Motivation : le leader peux prendre en charge:
\begin{itemize}
\item les communications
\item coordination des traitements des données (par exemple; dans les protocoles de validation)
\item Allocation de ressources
\item etc...
\end{itemize}
\end{itemize}
\paragraph{Cas simple l'anneau}
\begin{itemize}


\item Variantes : \begin{itemize}
\item bidirectionnel ou unidirectionnel
\item taille de l'anneau n connu ou inconnu
\end{itemize}
\end{itemize}

\paragraph{Nous avons besoin de qqc de plus}
\begin{itemize}
\item besoin de distinguer les processus
\item supposons un UID , s'il connaît
\item chaque processus démarre en stockant son pid
\item il sont comparable et pouvoir faire de l'arithmétique simple dessus est un plus
\item dans le réseau tous les identifiants sont différents
\end{itemize}
\paragraph{Un algorithme}
\begin{itemize}
\item autors : LeLann , Chang,Roberts
\item hypothèse 
\begin{itemize}
\item comm unidirectionnelle
\item les proc ne connaissent pas n
\item comparaison d'UID seulement
\end{itemize}
\item Idée: 
\begin{itemize}
\item chaque processus envoi son uid dans un message, à relayer étape par étape, autour de l'anneau.
\item le proc compare l'id reçu avec le sien , et envoi a son voisin le plus grand des deux entre le sien et celui reçu.
\end{itemize}
\end{itemize}

\paragraph{Preuve , complexité, terminaison}
\begin{itemize}
\item M, l'alphabet de messages : {UID}
\item état : valeur des variables :
\begin{itemize}
\item u : a pour valeur son pid
\item send, son pid ou false
\it status : ?  ou leader, initialement ?
\end{itemize}
\item start : défini par l'init des variables
\item msgs : transmet la valeur send à son voisin
\item trans : défini par le pseudo-code : 
\begin{itemize}
\item if incomming = v, a UID, then
\item \t case :
\item  v >  u  : send := v;
\item  v = u  : status := leader
\item  v<u : no-op
\item \t endcase
\end{itemize}
\end{itemize}

\paragraph{Réduire le nombre de communication}
\begin{itemize}
\item autor: Hirschberg,Sinclair
\item hypothèse : 
\begin{itemize}
\item bidirectionnel
\item les processus ne connaissent pas n
\item comparaisons d'id seulement
\end{itemize}
\item Idée : 
\begin{itemize}
\item Stratégie du doublement
\item Chaque processus envoie son UID dans les deux sens, à des distances de plus en plus grandes (successivement deux fois plus grande à chaque fois)
\item phase aller : un jeton est ignoré si il atteint un noeud dont l'uid est plus grand
\item phase retour : tout le monde passe le jeton
\it un processus débute la phase suivante que si ses deux jetons reviennent.
\it le processus qui reçoit son propre jeton dans la phase aller est l'élu.
\end{itemize}
\end{itemize}

\paragraph{Élection d'un leader}
\begin{itemize}
\item Hypothèse
\begin{itemize}
\item UID avec comparaisons.
\item pas d'hypothèse sur la répartition des UID
\item les processus connaissent un majorant du diamètre
\end{itemize}
\end{itemize}

\section{}
\date{14 Février 2013}
\paragraph{défaillance de processus} défaillance byzantine : chaque processus envoie sa valeur, le cas de l’arrêt fonctionne, nb rang = nb panne +1. byz: un menteur au moment du choix, va envoyer au suivant une mauvaise valeur .
\paragraph{collecte d'information exponentielle} valeur transmise le long d'un réseau en forme d'arbre. la première couche correspond au résultats reçu à l'étape numéro 1., le seconde correspond à la 2eme étape. le dernier chiffre du numéro marqué au dessus de la "feuille" c’est le dernier processus à avoir envoyer le message reçu. on peut ainsi remonter le chemin parcouru par le message.\\\\Chaque processus utilise la même structure d'arbre.\\les noeuds sont étiquetés par des valeurs\\\textbf{initialement} les têtes sont étiquetées par la valeur du noeuds\\\textbf{round r> 1} \begin{itemize}
\item envoyer le niveau r-1 à tous nœuds (soi même aussi)
\item utiliser les messages reçu pour étiqueter le niveau r
\item si pas de message utiliser $\bot$
\end{itemize}
\paragraph{règle de choix pour le cas de la panne d'arret : }
\begin{itemize}
\item triviale
\item on prend toutes les étiquettes de l'arbre
\item si un seul élément , on le prend
\item sinon on prend par défaut $v_0$
\end{itemize}
\paragraph{preuve et complexité}
\begin{itemize}
\item preuve  :  il y aura toujours un moment ou il n'y a pas de panne
\item complexité : nombre de panne +1 rounds, il envoi a tous ces voisins
\item complexité en nombre de message  : n-1 * nombre de pannes
\item défaut:  nombre de feuilles peut croître exponentiellement
\end{itemize}

\subsection{Algorithmes:  pannes byzantines}
\begin{itemize}
\item conditions : 
\begin{itemize}
\item accord : pas deux processus sans panne décide différemment
\item si tous les processus sans panne une valeur identique alors elle est choisie par tous les processus sans panne
\item Terminaison : tous les processus sans panne font un choix
\end{itemize}
\item EIG algorithme utilise : 
\begin{itemize}
\item un abre
\item f+1 rounds
\item n > 3f
\end{itemize}
\end{itemize}

\paragraph{mauvais exemple} 3 processus, 1 panne
supposons n > 3F : \\nouvelle règle de décision : 
\begin{itemize}
\item notons val(x) , la valeur du nœud x de l'arbre.
\item redécorer l'arbre 
\begin{itemize}
\item parcours de bas en haut pour trouver la valeur la plus fréquente.
\end{itemize}
\end{itemize}
\newpage
\date{18 Février 2013}
\section{Modèles asynchrones}
\subsection{réseaux asynchrones}
\paragraph{send/recv de  message}
Graphe G = (e,v), processus associé à chaque noeud et, un canal associé à chaque arc.\\\\\textbf{processus} interface utilisateur : inv, resp.\\problème spécifié en terme de trace autorisées au niveau utilisateur.
\paragraph{Canaux} différnets types de canaux : FIFO fiable, garantie fiable : perte, duplication, pas d'ordre.\\Peut ^etre définie comme une fonction sur un message d'entrée vers les messages de sortie. \\intégrité : préserve le message\\pas de perte\\pas de duplication\\respecte l'ordre.\\\\\textbf{broadcast et multicast} FIFO fiables enttre chaque noeud\\différents processus peuvent recevoir de différents émetteurs , mais sans contrainte d'ordre.
\subsection{Algorithmes sur des réseau asynchrones}
\paragraph{}Supposons que des FIFO fiables.
\begin{itemize}
\item Élection sur un anneau
\item idem sur un réseau
\item arbre couvrant minimum
\end{itemize}

\paragraph{} hypothèse : G est un anneau , unidirectionnel ou bidirectionnel, nom pour les voisins , uids\\\\ Il stocke ses messages dans sa fifo locale et attend que le canal soit libre pour envoyer.
\paragraph{Algorithme de Peterson} Baser sur la notion de phases . \\ Un processus est actif ou passif, les processus ne fond que relayer les messages\\Dans chaque phase la moitié des processus actif devient inactif, ainsi l’élection ne prend au plus n log n phases.\\\\\textbf{Phase 1 : } Envoyer UID de deux prédécesseurs, reste actif si l'uid du milieu est max.\\v autrement dit, chaque porcessus attend de recevoir les uids de ses deux prédecessurs, ainsi , il envoi son uid au suivant, et soit les trois uids recus, si celui du milieu n'est pas le max des trois, alors la processus passe en inactif(relay) et ne fera que passer des messages. Sinnon , il prend l'uid du milieu  et reste actif.\\
\end{document}
